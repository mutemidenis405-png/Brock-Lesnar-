import os

# ------------------------------
# Project Root
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Folder Structure
# ------------------------------
folders = [
    ".github/workflows",
    "app/src/main/java/com/monster/study",
    "app/src/main/assets",
]

# Create directories
for f in folders:
    os.makedirs(os.path.join(root, f), exist_ok=True)

# ------------------------------
# MonsterActivity.kt
# Core offline AI tutor + basic TTS + document reading
# ------------------------------
monster_kotlin_code = """package com.monster.study

import android.app.*
import android.content.*
import android.os.*
import android.speech.tts.TextToSpeech
import android.webkit.JavascriptInterface
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import java.io.File
import java.util.*

class MonsterActivity : AppCompatActivity(), TextToSpeech.OnInitListener {

    private lateinit var webView: WebView
    private lateinit var tts: TextToSpeech
    private val languages = mutableListOf(Locale.US)
    private var currentLangIndex = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        tts = TextToSpeech(this, this)

        webView = WebView(this)
        webView.settings.javaScriptEnabled = true
        webView.addJavascriptInterface(MonsterBridge(), "Monster")
        webView.webViewClient = WebViewClient()
        webView.loadUrl("file:///android_asset/index.html")

        setContentView(webView)
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) tts.language = Locale.US
    }

    inner class MonsterBridge {

        @JavascriptInterface
        fun speak(text: String) {
            tts.language = languages[currentLangIndex]
            tts.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)
            currentLangIndex = (currentLangIndex + 1) % languages.size
        }

        @JavascriptInterface
        fun downloadVoice(langCode: String) {
            val locale = Locale.forLanguageTag(langCode)
            val result = tts.setLanguage(locale)
            if(result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED){
                val intent = Intent()
                intent.action = TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA
                startActivity(intent)
            } else {
                if(!languages.contains(locale)) languages.add(locale)
                Toast.makeText(this@MonsterActivity,"Language $langCode ready",Toast.LENGTH_SHORT).show()
            }
        }

        @JavascriptInterface
        fun command(cmd: String) {
            when {
                cmd.contains("pause", true) -> tts.stop()
                cmd.contains("language", true) -> {
                    currentLangIndex = (currentLangIndex + 1) % languages.size
                    tts.language = languages[currentLangIndex]
                    Toast.makeText(this@MonsterActivity,"Language switched",Toast.LENGTH_SHORT).show()
                }
            }
        }

        @JavascriptInterface
        fun scheduleBreak(minutes: Int) {
            val intent = Intent(this@MonsterActivity, BreakReceiver::class.java)
            val pending = PendingIntent.getBroadcast(
                this@MonsterActivity, 0, intent, PendingIntent.FLAG_IMMUTABLE
            )
            val am = getSystemService(ALARM_SERVICE) as AlarmManager
            am.set(
                AlarmManager.RTC_WAKEUP,
                System.currentTimeMillis() + minutes * 60000,
                pending
            )
        }
    }

    class BreakReceiver: BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            Toast.makeText(context,"Time for a break!",Toast.LENGTH_LONG).show()
        }
    }
}
"""

# ------------------------------
# index.html
# Basic dashboard for offline AI + TTS
# ------------------------------
index_html = """
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Monster Personal Dashboard</title>
</head>
<body>
<h2>Monster Personal Dashboard</h2>
<textarea id="aiPrompt" placeholder="Ask Monster AI"></textarea>
<button onclick="askAI()">Ask AI</button>
<div id="aiAnswer"></div>
<button onclick="read()">Read Aloud</button>

<select id="langSelect">
  <option value="en-US">English (US)</option>
  <option value="en-GB">English (UK)</option>
  <option value="fr-FR">French</option>
  <option value="es-ES">Spanish</option>
  <option value="de-DE">German</option>
</select>
<button onclick="downloadLang()">Download Voice</button>

<script>
function read(){ const t=document.getElementById('aiPrompt').value; Monster.speak(t);}
function downloadLang(){ const lang=document.getElementById("langSelect").value; Monster.downloadVoice(lang);}
function askAI(){ alert('AI offline - placeholder for future enhancements');}
</script>
</body>
</html>
"""

# ------------------------------
# AndroidManifest.xml
# ------------------------------
manifest = """<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.monster.study">
<uses-permission android:name="android.permission.RECORD_AUDIO"/>
<application
    android:allowBackup="true"
    android:label="Monster Personal"
    android:supportsRtl="true"
    android:theme="@style/Theme.AppCompat.Light.NoActionBar">
    <activity android:name=".MonsterActivity" android:exported="true">
        <intent-filter>
            <action android:name="android.intent.action.MAIN"/>
            <category android:name="android.intent.category.LAUNCHER"/>
        </intent-filter>
    </activity>
</application>
</manifest>"""

# ------------------------------
# Gradle build files
# ------------------------------
root_build_gradle = """buildscript {
    repositories { google(); mavenCentral() }
    dependencies { classpath "com.android.tools.build:gradle:8.2.0" }
}
allprojects { repositories { google(); mavenCentral() } }"""

settings_gradle = """rootProject.name = "MonsterStudy_Personal"
include ':app'"""

app_build_gradle = """plugins { id 'com.android.application' }
android {
    namespace 'com.monster.study'
    compileSdk 34
    defaultConfig {
        applicationId "com.monster.study"
        minSdk 26
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }
    buildTypes { release { minifyEnabled false } }
}
dependencies {
    implementation "androidx.appcompat:appcompat:1.7.0"
}"""

# ------------------------------
# GitHub workflow (optional for personal build)
# ------------------------------
workflow = """name: Build Monster APK
on: [push, workflow_dispatch]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: 17
    - name: Set up Android SDK
      uses: android-actions/setup-android@v3
    - name: Grant execute permission for Gradle
      run: chmod +x ./gradlew
    - name: Build Debug APK
      run: ./gradlew assembleDebug
    - name: Upload APK
      uses: actions/upload-artifact@v4
      with:
        name: Monster-Personal-APK
        path: app/build/outputs/apk/debug/app-debug.apk"""

# ------------------------------
# Write all files
# ------------------------------
files = {
    "app/src/main/java/com/monster/study/MonsterActivity.kt": monster_kotlin_code,
    "app/src/main/assets/index.html": index_html,
    "app/src/main/AndroidManifest.xml": manifest,
    "build.gradle": root_build_gradle,
    "settings.gradle": settings_gradle,
    "app/build.gradle": app_build_gradle,
    ".github/workflows/android-build.yml": workflow,
}

for path, content in files.items():
    full_path = os.path.join(root, path)
    os.makedirs(os.path.dirname(full_path), exist_ok=True)
    with open(full_path, "w", encoding="utf-8") as f:
        f.write(content)

print(f"Monster Study Personal Edition - Phase 1 generated in folder '{root}'. You can now build the APK for personal use!")import os

# ------------------------------
# Phase 2: Offline Notes & Research
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Folder for user documents and notes
# ------------------------------
folders = [
    "app/src/main/assets/documents",
    "app/src/main/assets/notes",
]

for f in folders:
    os.makedirs(os.path.join(root, f), exist_ok=True)

# ------------------------------
# Update MonsterActivity.kt with offline research & note helpers
# ------------------------------
phase2_kotlin_update = """
package com.monster.study

import java.io.File
import java.io.FileInputStream
import org.apache.pdfbox.pdmodel.PDDocument
import org.apache.pdfbox.text.PDFTextStripper
import org.apache.poi.xwpf.usermodel.XWPFDocument

// Extend MonsterBridge inside MonsterActivity
inner class MonsterBridge {

    // Extract text from PDF
    @JavascriptInterface
    fun extractPdf(filePath: String): String {
        val file = File(filesDir, "assets/documents/$filePath")
        if (!file.exists()) return "File not found"
        val doc = PDDocument.load(file)
        val stripper = PDFTextStripper()
        val text = stripper.getText(doc)
        doc.close()
        return text
    }

    // Extract text from Word DOCX
    @JavascriptInterface
    fun extractDocx(filePath: String): String {
        val file = File(filesDir, "assets/documents/$filePath")
        if (!file.exists()) return "File not found"
        val fis = FileInputStream(file)
        val doc = XWPFDocument(fis)
        val text = doc.paragraphs.joinToString("\\n") { it.text }
        doc.close()
        return text
    }

    // Save generated notes
    @JavascriptInterface
    fun saveNote(noteName: String, content: String) {
        val file = File(filesDir, "assets/notes/$noteName.txt")
        file.writeText(content)
    }

    // List saved notes
    @JavascriptInterface
    fun listNotes(): Array<String> {
        val dir = File(filesDir, "assets/notes")
        return dir.list() ?: arrayOf()
    }

    // Simple offline research: filter high-yield words from document text
    @JavascriptInterface
    fun highYieldExtract(text: String): String {
        val keywords = listOf("important", "key", "summary", "definition", "formula")
        val lines = text.split("\\n")
        val filtered = lines.filter { line -> keywords.any { kw -> line.contains(kw, ignoreCase = true) } }
        return filtered.joinToString("\\n")
    }
}
"""

# ------------------------------
# Update index.html with offline note & research UI
# ------------------------------
phase2_index_html_update = """
<h3>Offline Notes & Research</h3>
<input type="text" id="docName" placeholder="Document filename (PDF/DOCX)">
<button onclick="loadDoc()">Load Document</button>
<textarea id="docText" rows="8" cols="50"></textarea><br>
<input type="text" id="noteName" placeholder="Note name">
<button onclick="saveNote()">Save Note</button>
<div id="notesList"></div>
<button onclick="refreshNotes()">Refresh Notes</button>

<script>
function loadDoc() {
    const name = document.getElementById('docName').value
    Monster.extractPdf(name) ? Monster.extractPdf(name).then(t=>document.getElementById('docText').value=t) : Monster.extractDocx(name).then(t=>document.getElementById('docText').value=t)
}

function saveNote() {
    const name = document.getElementById('noteName').value
    const content = document.getElementById('docText').value
    Monster.saveNote(name, content)
    alert('Note saved!')
}

function refreshNotes() {
    Monster.listNotes().then(notes => {
        const listDiv = document.getElementById('notesList')
        listDiv.innerHTML = '<b>Saved Notes:</b><br>' + notes.join('<br>')
    })
}
</script>
"""

# ------------------------------
# Write updated files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase2_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase2_index_html_update)

print("Phase 2 complete: Offline notes, PDF/DOCX extraction, and high-yield research helper added!")import os

# ------------------------------
# Phase 3: Timetable & Course Outline Integration
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Folder for timetables and course outlines
# ------------------------------
folders = [
    "app/src/main/assets/timetables",
    "app/src/main/assets/course_outlines",
]

for f in folders:
    os.makedirs(os.path.join(root, f), exist_ok=True)

# ------------------------------
# Update MonsterActivity.kt: load timetables & course outlines
# ------------------------------
phase3_kotlin_update = """
package com.monster.study

import java.io.File

// Extend MonsterBridge inside MonsterActivity
inner class MonsterBridge {

    // Load timetable file (simple CSV format: day,time,subject)
    @JavascriptInterface
    fun loadTimetable(fileName: String): String {
        val file = File(filesDir, "assets/timetables/$fileName")
        if (!file.exists()) return "Timetable not found"
        return file.readText()
    }

    // Load course outline (JSON or simple text)
    @JavascriptInterface
    fun loadCourseOutline(fileName: String): String {
        val file = File(filesDir, "assets/course_outlines/$fileName")
        if (!file.exists()) return "Course outline not found"
        return file.readText()
    }

    // Generate daily study plan from timetable & course outline
    @JavascriptInterface
    fun generateDailyPlan(timetableFile: String, outlineFile: String): String {
        val timetableText = loadTimetable(timetableFile)
        val outlineText = loadCourseOutline(outlineFile)

        val sessions = timetableText.split("\\n").map { it.split(",") } // day,time,subject
        val plan = StringBuilder()
        for (s in sessions) {
            if (s.size < 3) continue
            val day = s[0].trim()
            val time = s[1].trim()
            val subject = s[2].trim()
            val topic = outlineText.lines().find { it.contains(subject, ignoreCase = true) } ?: "General Revision"
            plan.append("$day $time - $subject: $topic\\n")
        }
        return plan.toString()
    }
}
"""

# ------------------------------
# Update index.html: timetable + daily plan UI
# ------------------------------
phase3_index_html_update = """
<h3>Timetable & Daily Plan</h3>
<input type="text" id="timetableFile" placeholder="Timetable CSV filename">
<input type="text" id="outlineFile" placeholder="Course Outline filename">
<button onclick="generatePlan()">Generate Daily Plan</button>
<textarea id="dailyPlan" rows="8" cols="50"></textarea>

<script>
function generatePlan() {
    const tFile = document.getElementById('timetableFile').value
    const oFile = document.getElementById('outlineFile').value
    Monster.generateDailyPlan(tFile, oFile).then(plan => {
        document.getElementById('dailyPlan').value = plan
    })
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase3_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase3_index_html_update)

print("Phase 3 complete: Timetable & course outline integration added, daily study plan ready!")
import os

# ------------------------------
# Phase 4: AI-Assisted Note Generation
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Folder for generated session notes
# ------------------------------
folders = [
    "app/src/main/assets/session_notes",
]

for f in folders:
    os.makedirs(os.path.join(root, f), exist_ok=True)

# ------------------------------
# Update MonsterActivity.kt: generate notes per session
# ------------------------------
phase4_kotlin_update = """
package com.monster.study

import java.io.File

// Extend MonsterBridge inside MonsterActivity
inner class MonsterBridge {

    // Generate notes for a subject/topic from document(s)
    @JavascriptInterface
    fun generateSessionNotes(subject: String, documentFiles: String): String {
        val docs = documentFiles.split(",").map { it.trim() }
        val notes = StringBuilder()
        notes.append("Session Notes for: $subject\\n\\n")
        for (doc in docs) {
            val file = File(filesDir, "assets/documents/$doc")
            if (!file.exists()) continue
            val text = when {
                doc.endsWith(".pdf") -> extractPdf(doc)
                doc.endsWith(".docx") -> extractDocx(doc)
                else -> file.readText()
            }
            // Simple high-yield extraction
            val filtered = highYieldExtract(text)
            notes.append(filtered).append("\\n\\n")
        }
        // Save to session notes folder
        val noteFile = File(filesDir, "assets/session_notes/${subject}_session.txt")
        noteFile.writeText(notes.toString())
        return notes.toString()
    }

    // List session notes
    @JavascriptInterface
    fun listSessionNotes(): Array<String> {
        val dir = File(filesDir, "assets/session_notes")
        return dir.list() ?: arrayOf()
    }
}
"""

# ------------------------------
# Update index.html: AI-generated notes UI
# ------------------------------
phase4_index_html_update = """
<h3>AI Session Notes</h3>
<input type="text" id="sessionSubject" placeholder="Subject/Topic">
<input type="text" id="docFiles" placeholder="Comma-separated document filenames">
<button onclick="generateNotes()">Generate Notes</button>
<textarea id="sessionNotes" rows="10" cols="60"></textarea>
<div id="sessionNotesList"></div>
<button onclick="refreshSessionNotes()">Refresh Notes</button>

<script>
function generateNotes() {
    const subject = document.getElementById('sessionSubject').value
    const docs = document.getElementById('docFiles').value
    Monster.generateSessionNotes(subject, docs).then(notes => {
        document.getElementById('sessionNotes').value = notes
    })
}

function refreshSessionNotes() {
    Monster.listSessionNotes().then(notes => {
        const div = document.getElementById('sessionNotesList')
        div.innerHTML = '<b>Saved Session Notes:</b><br>' + notes.join('<br>')
    })
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase4_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase4_index_html_update)

print("Phase 4 complete: AI-assisted note generation and session preparation added!")import os

# ------------------------------
# Phase 5: Dynamic Revision Exercises
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: revision helpers
# ------------------------------
phase5_kotlin_update = """
package com.monster.study

import kotlin.random.Random

// Extend MonsterBridge inside MonsterActivity
inner class MonsterBridge {

    // Generate Cloze (fill-in-the-blank) exercise from session note text
    @JavascriptInterface
    fun generateCloze(noteFile: String): String {
        val file = File(filesDir, "assets/session_notes/$noteFile")
        if (!file.exists()) return "Session note not found"
        val words = file.readText().split("\\s+").toMutableList()
        if (words.isEmpty()) return "No content"
        val idx = Random.nextInt(words.size)
        words[idx] = "____"
        return words.joinToString(" ")
    }

    // Generate a simple MCQ (for demo purposes, later can integrate AI analysis)
    @JavascriptInterface
    fun generateMCQ(noteFile: String): String {
        val file = File(filesDir, "assets/session_notes/$noteFile")
        if (!file.exists()) return "Session note not found"
        val lines = file.readText().split("\\n").filter { it.isNotBlank() }
        if (lines.isEmpty()) return "No content for MCQ"
        val question = lines[Random.nextInt(lines.size)]
        return "Q: $question\\nA) 1  B) 2  C) 3  D) 4"
    }

    // Recap first few lines of session note
    @JavascriptInterface
    fun generateRecap(noteFile: String): String {
        val file = File(filesDir, "assets/session_notes/$noteFile")
        if (!file.exists()) return "Session note not found"
        val lines = file.readText().split("\\n")
        return lines.take(5).joinToString("\\n")
    }
}
"""

# ------------------------------
# Update index.html: revision UI
# ------------------------------
phase5_index_html_update = """
<h3>Revision Exercises</h3>
<input type="text" id="revNoteFile" placeholder="Session note filename">
<button onclick="cloze()">Generate Cloze</button>
<button onclick="mcq()">Generate MCQ</button>
<button onclick="recap()">Generate Recap</button>
<textarea id="revOutput" rows="10" cols="60"></textarea>

<script>
function cloze() {
    const file = document.getElementById('revNoteFile').value
    Monster.generateCloze(file).then(t=>document.getElementById('revOutput').value=t)
}

function mcq() {
    const file = document.getElementById('revNoteFile').value
    Monster.generateMCQ(file).then(t=>document.getElementById('revOutput').value=t)
}

function recap() {
    const file = document.getElementById('revNoteFile').value
    Monster.generateRecap(file).then(t=>document.getElementById('revOutput').value=t)
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase5_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase5_index_html_update)

print("Phase 5 complete: Dynamic revision exercises (Cloze, MCQ, Recap) added!")import os

# ------------------------------
# Phase 6: Offline Voice Commands & Reading
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: voice and highlighting
# ------------------------------
phase6_kotlin_update = """
package com.monster.study

import android.speech.tts.TextToSpeech
import android.webkit.JavascriptInterface
import android.widget.Toast
import java.util.*

inner class MonsterBridge {

    private val languages = mutableListOf(Locale.US)
    private var currentLangIndex = 0

    // Speak text aloud
    @JavascriptInterface
    fun speakText(text: String) {
        tts.language = languages[currentLangIndex]
        tts.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)
        currentLangIndex = (currentLangIndex + 1) % languages.size
    }

    // Change TTS language
    @JavascriptInterface
    fun switchLanguage() {
        currentLangIndex = (currentLangIndex + 1) % languages.size
        tts.language = languages[currentLangIndex]
        Toast.makeText(this@MonsterActivity,"Language switched", Toast.LENGTH_SHORT).show()
    }

    // Highlight text via font color
    @JavascriptInterface
    fun highlightText(text: String, color: String = "yellow") {
        // JS will handle selection coloring, just pass parameters
    }

    // Pause TTS
    @JavascriptInterface
    fun pauseTTS() {
        tts.stop()
    }
}
"""

# ------------------------------
# Update index.html: voice & highlight UI
# ------------------------------
phase6_index_html_update = """
<h3>Voice & Highlighting</h3>
<textarea id="voiceText" rows="5" cols="60" placeholder="Type text to read aloud"></textarea><br>
<button onclick="speak()">Read Aloud</button>
<button onclick="pauseTTS()">Pause</button>
<button onclick="switchLang()">Switch Language</button>
<input type="color" id="highlightColor" value="#FFFF00">
<button onclick="highlightSelection()">Highlight Selection</button>

<script>
function speak() {
    const t = document.getElementById('voiceText').value
    Monster.speakText(t)
}

function pauseTTS() {
    Monster.pauseTTS()
}

function switchLang() {
    Monster.switchLanguage()
}

function highlightSelection() {
    const sel = window.getSelection().toString()
    const color = document.getElementById('highlightColor').value
    if(sel) Monster.highlightText(sel, color)
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase6_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase6_index_html_update)

print("Phase 6 complete: Offline voice commands, TTS, and text highlighting added!")import os

# ------------------------------
# Phase 7: Dynamic Video Recommendations
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: video recommendation logic
# ------------------------------
phase7_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import java.util.*

inner class MonsterBridge {

    // Simulated video library (URL or local asset)
    private val videoLibrary = mapOf(
        "Math" to listOf(
            "https://youtu.be/math_short1",
            "https://youtu.be/math_short2",
            "https://youtu.be/math_short3"
        ),
        "Physics" to listOf(
            "https://youtu.be/physics_short1",
            "https://youtu.be/physics_short2"
        )
    )

    // Get a random video URL for a subject
    @JavascriptInterface
    fun getVideo(subject: String): String {
        val vids = videoLibrary[subject] ?: return "No videos available"
        return vids[Random().nextInt(vids.size)]
    }
}
"""

# ------------------------------
# Update index.html: video recommendation UI
# ------------------------------
phase7_index_html_update = """
<h3>Dynamic Video Recommendations</h3>
<input type="text" id="videoSubject" placeholder="Subject/Topic">
<button onclick="showVideo()">Show Video</button>
<button onclick="nextVideo()">Next Video</button>
<div id="videoDisplay"></div>

<script>
let currentVideo = ""
function showVideo() {
    const subj = document.getElementById('videoSubject').value
    Monster.getVideo(subj).then(url => {
        currentVideo = url
        document.getElementById('videoDisplay').innerHTML = '<iframe width="400" height="225" src="'+url+'" frameborder="0" allowfullscreen></iframe>'
    })
}

function nextVideo() {
    const subj = document.getElementById('videoSubject').value
    Monster.getVideo(subj).then(url => {
        currentVideo = url
        document.getElementById('videoDisplay').innerHTML = '<iframe width="400" height="225" src="'+url+'" frameborder="0" allowfullscreen></iframe>'
    })
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase7_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase7_index_html_update)

print("Phase 7 complete: Dynamic topic-based video recommendations added!")import os

# ------------------------------
# Phase 8: Offline Memory & Recall
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Folder for offline memory
# ------------------------------
folders = [
    "app/src/main/assets/memory",
]

for f in folders:
    os.makedirs(os.path.join(root, f), exist_ok=True)

# ------------------------------
# Update MonsterActivity.kt: memory management
# ------------------------------
phase8_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import java.io.File

inner class MonsterBridge {

    // Save memory entry
    @JavascriptInterface
    fun remember(key: String, content: String): String {
        val file = File(filesDir, "assets/memory/${key}.txt")
        file.writeText(content)
        return "Memory saved for: $key"
    }

    // Retrieve memory
    @JavascriptInterface
    fun recall(key: String): String {
        val file = File(filesDir, "assets/memory/${key}.txt")
        return if(file.exists()) file.readText() else "No memory found for: $key"
    }

    // Delete memory
    @JavascriptInterface
    fun forget(key: String): String {
        val file = File(filesDir, "assets/memory/${key}.txt")
        return if(file.exists() && file.delete()) "Memory deleted: $key" else "No memory to delete for: $key"
    }

    // List all memories
    @JavascriptInterface
    fun listMemories(): Array<String> {
        val dir = File(filesDir, "assets/memory")
        return dir.list() ?: arrayOf()
    }
}
"""

# ------------------------------
# Update index.html: memory UI
# ------------------------------
phase8_index_html_update = """
<h3>Offline Memory</h3>
<input type="text" id="memKey" placeholder="Memory Key/Title">
<textarea id="memContent" rows="4" cols="60" placeholder="Text to remember"></textarea><br>
<button onclick="saveMemory()">Remember</button>
<button onclick="recallMemory()">Recall</button>
<button onclick="deleteMemory()">Forget</button>
<button onclick="listMemory()">List Memories</button>
<div id="memoryOutput"></div>

<script>
function saveMemory() {
    const key = document.getElementById('memKey').value
    const content = document.getElementById('memContent').value
    Monster.remember(key, content).then(msg=>alert(msg))
}

function recallMemory() {
    const key = document.getElementById('memKey').value
    Monster.recall(key).then(text=>document.getElementById('memoryOutput').innerText=text)
}

function deleteMemory() {
    const key = document.getElementById('memKey').value
    Monster.forget(key).then(msg=>alert(msg))
}

function listMemory() {
    Monster.listMemories().then(list=>{
        document.getElementById('memoryOutput').innerText=list.join("\\n")
    })
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase8_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase8_index_html_update)

print("Phase 8 complete: Offline memory storage and recall added!")import os

# ------------------------------
# Phase 9: Group Sessions & AI-Assisted Tutoring
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: group session logic
# ------------------------------
phase9_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import java.util.*

inner class MonsterBridge {

    // Simulated group participants
    private val participants = mutableListOf("Alice", "Bob", "Charlie", "Dave")

    // Monster selects a participant randomly to answer
    @JavascriptInterface
    fun selectRandomParticipant(): String {
        if(participants.isEmpty()) return "No participants in session"
        return participants[Random().nextInt(participants.size)]
    }

    // Raise hand in session
    @JavascriptInterface
    fun raiseHand(name: String): String {
        return "$name has raised a hand"
    }

    // Silent text question
    @JavascriptInterface
    fun submitQuestion(name: String, question: String): String {
        // Monster can respond asynchronously in future phases
        return "$name asked: $question"
    }

    // List participants
    @JavascriptInterface
    fun listParticipants(): Array<String> {
        return participants.toTypedArray()
    }
}
"""

# ------------------------------
# Update index.html: group session UI
# ------------------------------
phase9_index_html_update = """
<h3>Group Session</h3>
<input type="text" id="userName" placeholder="Your Name">
<input type="text" id="userQuestion" placeholder="Your Question">
<button onclick="raiseHand()">Raise Hand</button>
<button onclick="submitQuestion()">Submit Question</button>
<button onclick="pickRandom()">Pick Random Participant</button>
<div id="groupOutput"></div>

<script>
function raiseHand() {
    const name = document.getElementById('userName').value
    Monster.raiseHand(name).then(msg => document.getElementById('groupOutput').innerText=msg)
}

function submitQuestion() {
    const name = document.getElementById('userName').value
    const q = document.getElementById('userQuestion').value
    Monster.submitQuestion(name, q).then(msg => document.getElementById('groupOutput').innerText=msg)
}

function pickRandom() {
    Monster.selectRandomParticipant().then(msg => document.getElementById('groupOutput').innerText="Selected: "+msg)
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase9_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase9_index_html_update)

print("Phase 9 complete: Group sessions and AI-assisted tutoring added!")import os

# ------------------------------
# Phase 10: Timetable & Course Outline Automation
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Create folders for timetable and outlines
# ------------------------------
folders = [
    "app/src/main/assets/timetables",
    "app/src/main/assets/course_outlines"
]

for f in folders:
    os.makedirs(os.path.join(root, f), exist_ok=True)

# ------------------------------
# Update MonsterActivity.kt: timetable automation
# ------------------------------
phase10_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import java.io.File

inner class MonsterBridge {

    // Load timetable (simple text-based CSV format)
    @JavascriptInterface
    fun loadTimetable(fileName: String): String {
        val file = File(filesDir, "assets/timetables/$fileName")
        return if(file.exists()) file.readText() else "Timetable not found"
    }

    // Load course outline for a subject
    @JavascriptInterface
    fun loadCourseOutline(subject: String): String {
        val file = File(filesDir, "assets/course_outlines/${subject}.txt")
        return if(file.exists()) file.readText() else "Course outline not found for $subject"
    }

    // Generate daily study plan based on timetable and outline
    @JavascriptInterface
    fun generateDailyPlan(timetableFile: String): String {
        val timetable = loadTimetable(timetableFile)
        val lines = timetable.split("\\n").filter { it.isNotBlank() }
        val plan = StringBuilder()
        for(line in lines) {
            val parts = line.split(",") // e.g., "09:00,Math,Topic1"
            if(parts.size >= 3) {
                val time = parts[0].trim()
                val subject = parts[1].trim()
                val topic = parts[2].trim()
                val outline = loadCourseOutline(subject)
                plan.append("$time - $subject: $topic\\n")
                plan.append("Outline: $outline\\n\\n")
            }
        }
        return plan.toString()
    }
}
"""

# ------------------------------
# Update index.html: timetable UI
# ------------------------------
phase10_index_html_update = """
<h3>Daily Study Planner</h3>
<input type="text" id="timetableFile" placeholder="Timetable Filename">
<button onclick="generatePlan()">Generate Plan</button>
<textarea id="dailyPlan" rows="15" cols="70" placeholder="Daily plan will appear here"></textarea>

<script>
function generatePlan() {
    const file = document.getElementById('timetableFile').value
    Monster.generateDailyPlan(file).then(plan=>{
        document.getElementById('dailyPlan').value = plan
    })
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase10_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase10_index_html_update)

print("Phase 10 complete: Timetable and course outline automation added!")import os

# ------------------------------
# Phase 11: Misleading Information Detection
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: misleading info detection
# ------------------------------
phase11_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface

inner class MonsterBridge {

    // Simple heuristic detection of misleading info (keywords, contradictions)
    @JavascriptInterface
    fun detectMisleading(content: String): String {
        val warnings = mutableListOf<String>()
        val lower = content.lowercase()

        // Basic heuristics: "always", "never", "impossible" as potential red flags
        val flagWords = listOf("always", "never", "impossible", "every", "none")
        for(word in flagWords) {
            if(lower.contains(word)) warnings.add("Potential misleading word: '$word'")
        }

        return if(warnings.isEmpty()) "No misleading content detected" else warnings.joinToString("\\n")
    }
}
"""

# ------------------------------
# Update index.html: misleading detection UI
# ------------------------------
phase11_index_html_update = """
<h3>Misleading Info Detector</h3>
<textarea id="contentCheck" rows="6" cols="70" placeholder="Paste text to check"></textarea><br>
<button onclick="checkMisleading()">Check Content</button>
<div id="misleadingOutput"></div>

<script>
function checkMisleading() {
    const content = document.getElementById('contentCheck').value
    Monster.detectMisleading(content).then(result => {
        document.getElementById('misleadingOutput').innerText = result
    })
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase11_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase11_index_html_update)

print("Phase 11 complete: Misleading information detection added!")import os

# ------------------------------
# Phase 12: Mind Maps & Topic Visualization
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: mind map support
# ------------------------------
phase12_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import org.json.JSONObject

inner class MonsterBridge {

    // Generate a simple mind map from JSON structure
    @JavascriptInterface
    fun generateMindMap(topic: String, subtopicsJson: String): String {
        // subtopicsJson is a JSON array: ["Sub1","Sub2",...]
        val json = JSONObject()
        json.put("topic", topic)
        json.put("subtopics", subtopicsJson)
        return json.toString() // JS will handle rendering
    }
}
"""

# ------------------------------
# Update index.html: mind map UI
# ------------------------------
phase12_index_html_update = """
<h3>Mind Map Generator</h3>
<input type="text" id="mapTopic" placeholder="Main Topic">
<textarea id="mapSubtopics" rows="3" cols="60" placeholder='Subtopics JSON, e.g., ["Sub1","Sub2"]'></textarea><br>
<button onclick="createMindMap()">Generate Mind Map</button>
<div id="mindMapDisplay" style="border:1px solid #000;padding:10px;"></div>

<script>
function createMindMap() {
    const topic = document.getElementById('mapTopic').value
    const subtopics = document.getElementById('mapSubtopics').value
    Monster.generateMindMap(topic, subtopics).then(jsonStr => {
        const obj = JSON.parse(jsonStr)
        let html = '<strong>' + obj.topic + '</strong><ul>'
        JSON.parse(obj.subtopics).forEach(sub => {
            html += '<li>' + sub + '</li>'
        })
        html += '</ul>'
        document.getElementById('mindMapDisplay').innerHTML = html
    })
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase12_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase12_index_html_update)

print("Phase 12 complete: Mind maps and topic visualization added!")import os

# ------------------------------
# Phase 13: AI-Assisted Revision (Cloze, Recap, MCQs)
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: revision logic
# ------------------------------
phase13_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import java.util.*

inner class MonsterBridge {

    // Recap first few sentences
    @JavascriptInterface
    fun recapText(content: String, sentenceCount: Int = 5): String {
        val sentences = content.split(".").map { it.trim() }.filter { it.isNotEmpty() }
        return sentences.take(sentenceCount).joinToString(". ") + if(sentences.size>sentenceCount) "..." else ""
    }

    // Generate simple cloze (fill-in-the-blank) test
    @JavascriptInterface
    fun generateCloze(content: String): String {
        val words = content.split(" ").filter { it.length>3 }
        if(words.isEmpty()) return "Not enough content for cloze"
        val randomWord = words[Random().nextInt(words.size)]
        return content.replaceFirst(randomWord, "____")
    }

    // Generate a simple MCQ
    @JavascriptInterface
    fun generateMCQ(question: String, correct: String, wrongs: Array<String>): String {
        val options = wrongs.toMutableList()
        options.add(correct)
        options.shuffle()
        val sb = StringBuilder()
        sb.append("Q: $question\\n")
        options.forEachIndexed { i, opt -> sb.append("${'A'+i}) $opt\\n") }
        return sb.toString()
    }
}
"""

# ------------------------------
# Update index.html: revision UI
# ------------------------------
phase13_index_html_update = """
<h3>AI-Assisted Revision</h3>
<textarea id="revisionText" rows="6" cols="70" placeholder="Paste text for revision"></textarea><br>
<button onclick="recap()">Recap</button>
<button onclick="cloze()">Cloze Test</button>
<button onclick="mcq()">MCQ Example</button>
<div id="revisionOutput"></div>

<script>
function recap() {
    const content = document.getElementById('revisionText').value
    Monster.recapText(content,5).then(result => document.getElementById('revisionOutput').innerText=result)
}

function cloze() {
    const content = document.getElementById('revisionText').value
    Monster.generateCloze(content).then(result => document.getElementById('revisionOutput').innerText=result)
}

function mcq() {
    // Example MCQ; in future can be generated from content
    Monster.generateMCQ("What is 2+2?", "4", ["3","5","6"]).then(result => document.getElementById('revisionOutput').innerText=result)
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase13_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase13_index_html_update)

print("Phase 13 complete: AI-assisted revision tools (recap, cloze, MCQs) added!")import os

# ------------------------------
# Phase 14: Dynamic Video Recommendations
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: video recommendations
# ------------------------------
phase14_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface

inner class MonsterBridge {

    // Sample video repository per topic
    private val videoLibrary = mapOf(
        "Math" to listOf("math1.mp4","math2.mp4","math3.mp4"),
        "Physics" to listOf("physics1.mp4","physics2.mp4"),
        "Chemistry" to listOf("chem1.mp4","chem2.mp4")
    )

    private val lastPlayed = mutableMapOf<String, Int>()

    @JavascriptInterface
    fun getVideoForTopic(topic: String): String {
        val videos = videoLibrary[topic] ?: return "No videos for this topic"
        val lastIndex = lastPlayed.getOrDefault(topic,-1)
        val nextIndex = (lastIndex + 1) % videos.size
        lastPlayed[topic] = nextIndex
        return videos[nextIndex]
    }

    @JavascriptInterface
    fun requestNewVideo(topic: String): String {
        val videos = videoLibrary[topic] ?: return "No videos for this topic"
        val currentIndex = lastPlayed.getOrDefault(topic,-1)
        val newIndex = (0 until videos.size).filter { it != currentIndex }.random()
        lastPlayed[topic] = newIndex
        return videos[newIndex]
    }
}
"""

# ------------------------------
# Update index.html: video UI
# ------------------------------
phase14_index_html_update = """
<h3>Topic Video Recommendations</h3>
<input type="text" id="videoTopic" placeholder="Enter Topic (e.g., Math)">
<button onclick="playVideo()">Play Video</button>
<button onclick="requestNewVideo()">Request New Video</button>
<div id="videoOutput"></div>

<script>
function playVideo() {
    const topic = document.getElementById('videoTopic').value
    Monster.getVideoForTopic(topic).then(video => {
        document.getElementById('videoOutput').innerText = "Video: " + video
        // Future: embed video player
    })
}

function requestNewVideo() {
    const topic = document.getElementById('videoTopic').value
    Monster.requestNewVideo(topic).then(video => {
        document.getElementById('videoOutput').innerText = "New Video: " + video
        // Future: embed video player
    })
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase14_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase14_index_html_update)

print("Phase 14 complete: Dynamic, topic-focused video recommendations added!")import os

# ------------------------------
# Phase 15: Online Study Groups & AI Participation
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: online group logic
# ------------------------------
phase15_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface

inner class MonsterBridge {

    // Simulated online groups
    private val onlineGroups = mutableMapOf(
        "MathStudy" to mutableListOf("Alice","Bob","Charlie"),
        "PhysicsStudy" to mutableListOf("Dave","Eve","Frank")
    )

    @JavascriptInterface
    fun joinGroup(groupName: String, participant: String): String {
        val group = onlineGroups.getOrPut(groupName) { mutableListOf() }
        if(!group.contains(participant)) group.add(participant)
        return "$participant joined $groupName"
    }

    @JavascriptInterface
    fun listGroupParticipants(groupName: String): Array<String> {
        return onlineGroups[groupName]?.toTypedArray() ?: arrayOf("No participants")
    }

    @JavascriptInterface
    fun aiParticipate(groupName: String): String {
        return "Monster AI is participating in $groupName"
    }

    @JavascriptInterface
    fun leaveGroup(groupName: String, participant: String): String {
        onlineGroups[groupName]?.remove(participant)
        return "$participant left $groupName"
    }
}
"""

# ------------------------------
# Update index.html: online group UI
# ------------------------------
phase15_index_html_update = """
<h3>Online Study Groups</h3>
<input type="text" id="groupName" placeholder="Group Name">
<input type="text" id="participantName" placeholder="Your Name"><br>
<button onclick="joinGroup()">Join Group</button>
<button onclick="leaveGroup()">Leave Group</button>
<button onclick="aiJoin()">Monster AI Join</button>
<div id="groupStatus"></div>

<script>
function joinGroup() {
    const group = document.getElementById('groupName').value
    const name = document.getElementById('participantName').value
    Monster.joinGroup(group,name).then(msg => document.getElementById('groupStatus').innerText=msg)
}

function leaveGroup() {
    const group = document.getElementById('groupName').value
    const name = document.getElementById('participantName').value
    Monster.leaveGroup(group,name).then(msg => document.getElementById('groupStatus').innerText=msg)
}

function aiJoin() {
    const group = document.getElementById('groupName').value
    Monster.aiParticipate(group).then(msg => document.getElementById('groupStatus').innerText=msg)
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase15_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase15_index_html_update)

print("Phase 15 complete: Online study groups with AI participation added!")import os

# ------------------------------
# Phase 16: Interactive AI Tutor with Smart Board
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: AI Tutor logic
# ------------------------------
phase16_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import java.util.*

inner class MonsterBridge {

    private val participants = mutableListOf<String>()
    private var smartBoardContent: String = ""

    // Register participants for tutoring
    @JavascriptInterface
    fun registerParticipants(namesJson: String) {
        val names = namesJson.replace("[","").replace("]","").replace('"','').split(",").map{it.trim()}
        participants.clear()
        participants.addAll(names)
    }

    // Randomly select participant to answer
    @JavascriptInterface
    fun selectParticipant(): String {
        if(participants.isEmpty()) return "No participants registered"
        return participants[Random().nextInt(participants.size)]
    }

    // Update Smart Board content
    @JavascriptInterface
    fun updateSmartBoard(content: String) {
        smartBoardContent = content
    }

    @JavascriptInterface
    fun viewSmartBoard(): String {
        return smartBoardContent
    }

    // AI fetches online info for questions beyond local notes
    @JavascriptInterface
    fun fetchOnlineInfo(query: String): String {
        // placeholder: in real app, implement search API
        return "Fetched online info for: $query"
    }

    // Participant overrides: view notes or interact
    @JavascriptInterface
    fun overrideBoard(action: String, content: String = ""): String {
        return when(action.lowercase()) {
            "view_notes" -> "Displaying notes: $content"
            "interact" -> "Participant interaction: $content"
            else -> "Unknown action"
        }
    }
}
"""

# ------------------------------
# Update index.html: AI Tutor UI
# ------------------------------
phase16_index_html_update = """
<h3>Interactive AI Tutor</h3>
<textarea id="boardContent" rows="4" cols="70" placeholder="Write on Smart Board"></textarea><br>
<input type="text" id="participantNames" placeholder='Participants JSON e.g., ["Alice","Bob"]'><br>
<button onclick="register()">Register Participants</button>
<button onclick="select()">Select Participant</button>
<button onclick="updateBoard()">Update Smart Board</button>
<button onclick="viewBoard()">View Smart Board</button>
<button onclick="fetchInfo()">Fetch Online Info</button>
<div id="tutorOutput"></div>

<script>
function register() {
    const names = document.getElementById('participantNames').value
    Monster.registerParticipants(names).then(()=> document.getElementById('tutorOutput').innerText="Participants registered")
}

function select() {
    Monster.selectParticipant().then(p => document.getElementById('tutorOutput').innerText="Selected: "+p)
}

function updateBoard() {
    const content = document.getElementById('boardContent').value
    Monster.updateSmartBoard(content).then(()=> document.getElementById('tutorOutput').innerText="Smart Board updated")
}

function viewBoard() {
    Monster.viewSmartBoard().then(c => document.getElementById('tutorOutput').innerText="Smart Board: "+c)
}

function fetchInfo() {
    const query = document.getElementById('boardContent').value
    Monster.fetchOnlineInfo(query).then(info => document.getElementById('tutorOutput').innerText=info)
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase16_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase16_index_html_update)

print("Phase 16 complete: Interactive AI Tutor with Smart Board and dynamic participant selection added!")import os

# ------------------------------
# Phase 17: Participant Interactions (Raise Hand & Silent Questions)
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: participant interaction logic
# ------------------------------
phase17_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import java.util.*

inner class MonsterBridge {

    private val raisedHands = mutableListOf<String>()
    private val silentQuestions = mutableListOf<Pair<String,String>>() // Pair<Participant, Question>

    // Participant raises hand
    @JavascriptInterface
    fun raiseHand(participant: String): String {
        if(!raisedHands.contains(participant)) raisedHands.add(participant)
        return "$participant raised hand"
    }

    // List raised hands
    @JavascriptInterface
    fun listRaisedHands(): String {
        return if(raisedHands.isEmpty()) "No hands raised" else raisedHands.joinToString(", ")
    }

    // Clear hands after answering
    @JavascriptInterface
    fun clearHands() {
        raisedHands.clear()
    }

    // Submit silent question
    @JavascriptInterface
    fun submitSilentQuestion(participant: String, question: String) {
        silentQuestions.add(Pair(participant, question))
    }

    // AI answers silent questions
    @JavascriptInterface
    fun answerSilentQuestions(): String {
        if(silentQuestions.isEmpty()) return "No silent questions"
        val sb = StringBuilder()
        silentQuestions.forEach { (p,q) ->
            sb.append("Question from $p: $q\\n")
            sb.append("Monster AI Answer: [Answer generated]\\n\\n")
        }
        silentQuestions.clear()
        return sb.toString()
    }
}
"""

# ------------------------------
# Update index.html: interaction UI
# ------------------------------
phase17_index_html_update = """
<h3>Participant Interaction</h3>
<input type="text" id="participantNameInteract" placeholder="Your Name">
<input type="text" id="silentQuestion" placeholder="Type question for silent submission"><br>
<button onclick="raiseHand()">Raise Hand</button>
<button onclick="listHands()">List Raised Hands</button>
<button onclick="clearHands()">Clear Hands</button>
<button onclick="submitQuestion()">Submit Silent Question</button>
<button onclick="answerQuestions()">AI Answer Silent Questions</button>
<div id="interactionOutput"></div>

<script>
function raiseHand() {
    const name = document.getElementById('participantNameInteract').value
    Monster.raiseHand(name).then(msg => document.getElementById('interactionOutput').innerText=msg)
}

function listHands() {
    Monster.listRaisedHands().then(msg => document.getElementById('interactionOutput').innerText=msg)
}

function clearHands() {
    Monster.clearHands().then(() => document.getElementById('interactionOutput').innerText="Hands cleared")
}

function submitQuestion() {
    const name = document.getElementById('participantNameInteract').value
    const question = document.getElementById('silentQuestion').value
    Monster.submitSilentQuestion(name,question)
    document.getElementById('interactionOutput').innerText="Silent question submitted"
}

function answerQuestions() {
    Monster.answerSilentQuestions().then(ans => document.getElementById('interactionOutput').innerText=ans)
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase17_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase17_index_html_update)

print("Phase 17 complete: Raise-hand and silent question system added for interactive AI tutoring!")import os

# ------------------------------
# Phase 18: Automated Study Planning
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: study plan logic
# ------------------------------
phase18_kotlin_update = """
package com.monster.study

import android.webkit.JavascriptInterface
import java.util.*

inner class MonsterBridge {

    private val studyPlan = mutableListOf<String>()
    private var sessionBreakMinutes = 5

    // Upload timetable or course outline
    @JavascriptInterface
    fun uploadOutline(topicsJson: String) {
        val topics = topicsJson.replace("[","").replace("]","").replace('"','').split(",").map{it.trim()}
        studyPlan.clear()
        studyPlan.addAll(topics)
    }

    // Generate daily schedule with optional breaks
    @JavascriptInterface
    fun generateDailyPlan(): String {
        if(studyPlan.isEmpty()) return "No topics uploaded"
        val sb = StringBuilder()
        studyPlan.forEachIndexed { i, topic ->
            sb.append("Session ${i+1}: $topic\\n")
            sb.append("Break: $sessionBreakMinutes minutes\\n\\n")
        }
        return sb.toString()
    }

    @JavascriptInterface
    fun setBreak(minutes: Int) {
        sessionBreakMinutes = minutes
    }

    // Fetch sample past paper questions for a topic
    @JavascriptInterface
    fun fetchPastQuestions(topic: String): String {
        // placeholder for real online query
        return "Sample past paper questions for $topic"
    }
}
"""

# ------------------------------
# Update index.html: study plan UI
# ------------------------------
phase18_index_html_update = """
<h3>Automated Study Planner</h3>
<textarea id="courseOutline" rows="4" cols="70" placeholder='Enter topics as JSON e.g., ["Math","Physics"]'></textarea><br>
<input type="number" id="breakMinutes" placeholder="Break Minutes"><br>
<button onclick="uploadOutline()">Upload Outline</button>
<button onclick="setBreak()">Set Break</button>
<button onclick="generatePlan()">Generate Daily Plan</button>
<input type="text" id="questionTopic" placeholder="Topic for Past Questions">
<button onclick="fetchQuestions()">Fetch Past Questions</button>
<div id="planOutput"></div>

<script>
function uploadOutline() {
    const outline = document.getElementById('courseOutline').value
    Monster.uploadOutline(outline).then(()=> document.getElementById('planOutput').innerText="Outline uploaded")
}

function setBreak() {
    const mins = parseInt(document.getElementById('breakMinutes').value)
    Monster.setBreak(mins).then(()=> document.getElementById('planOutput').innerText="Break set")
}

function generatePlan() {
    Monster.generateDailyPlan().then(plan => document.getElementById('planOutput').innerText=plan)
}

function fetchQuestions() {
    const topic = document.getElementById('questionTopic').value
    Monster.fetchPastQuestions(topic).then(qs => document.getElementById('planOutput').innerText=qs)
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase18_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase18_index_html_update)

print("Phase 18 complete: Automated timetable and course outline-based study planning added!")import os

# ------------------------------
# Phase 19: Interphase Breaks & Focus Management
# ------------------------------
root = "MonsterStudy_Personal"

# ------------------------------
# Update MonsterActivity.kt: Break notifications
# ------------------------------
phase19_kotlin_update = """
package com.monster.study

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.webkit.JavascriptInterface
import android.widget.Toast

inner class MonsterBridge {

    private var breakMinutes: Int = 5

    @JavascriptInterface
    fun setSessionBreak(minutes: Int) {
        breakMinutes = minutes
    }

    @JavascriptInterface
    fun startBreak() {
        val intent = Intent(this@MonsterActivity, BreakReceiver::class.java)
        val pending = PendingIntent.getBroadcast(this@MonsterActivity, 0, intent, PendingIntent.FLAG_IMMUTABLE)
        val am = getSystemService(ALARM_SERVICE) as AlarmManager
        am.set(
            AlarmManager.RTC_WAKEUP,
            System.currentTimeMillis() + breakMinutes * 60000,
            pending
        )
    }
}

class BreakReceiver: BroadcastReceiver() {
    override fun onReceive(context: Context?, intent: Intent?) {
        Toast.makeText(context, "Break over! Time to resume studying.", Toast.LENGTH_LONG).show()
    }
}
"""

# ------------------------------
# Update index.html: break UI
# ------------------------------
phase19_index_html_update = """
<h3>Interphase Breaks</h3>
<input type="number" id="breakLength" placeholder="Break Minutes"><br>
<button onclick="setBreak()">Set Break Length</button>
<button onclick="startBreak()">Start Break</button>
<div id="breakOutput"></div>

<script>
function setBreak() {
    const mins = parseInt(document.getElementById('breakLength').value)
    Monster.setSessionBreak(mins).then(()=> document.getElementById('breakOutput').innerText="Break set for "+mins+" minutes")
}

function startBreak() {
    Monster.startBreak().then(()=> document.getElementById('breakOutput').innerText="Break started")
}
</script>
"""

# ------------------------------
# Append updates to existing files
# ------------------------------
activity_path = os.path.join(root, "app/src/main/java/com/monster/study/MonsterActivity.kt")
with open(activity_path, "a", encoding="utf-8") as f:
    f.write(phase19_kotlin_update)

index_path = os.path.join(root, "app/src/main/assets/index.html")
with open(index_path, "a", encoding="utf-8") as f:
    f.write(phase19_index_html_update)

print("Phase 19 complete: Interphase breaks and focus management added!")
